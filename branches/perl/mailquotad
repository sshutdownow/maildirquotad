#!/usr/bin/perl -w
use strict;

#  	mailquotad - is used to determine whether Maildir quota is exeeded before message will be accepted at SMTP (RCPT TO) time.
#
#   	Copyright (C) 2008 Igor Popov <ipopovi@gmail.com>
#	
#	This program is free software; you can redistribute it and/or
#	modify it under the terms of the GNU General Public License
#	as published by the Free Software Foundation; either version 2
#	of the License, or (at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
						

use Getopt::Std;
use POSIX;
use File::Basename;
use Fcntl qw/LOCK_EX LOCK_NB/;
use File::Find;
use IO::Socket;

use vars qw/$sockname $pidfile $debugmode $server_user $server_group
    $mail_spool_prefix $opt_h $opt_d $opt_s $opt_p $opt_u $opt_g $opt_m/;


# default values
$sockname = '/var/run/quotad/mailquotad.sock';
$pidfile  = '/var/run/quotad/mailquotad.pid';
$mail_spool_prefix = '/var/spool/mail';
$server_user = 'mailnull';
$server_group = 'mailnull';
$debugmode = 0;


getopts('hd:s:p:u:g:m:');

if ($opt_h) {
    print <<'USAGE';
-h this help message
-d <maildir> run in debug mode, do not became daemon
-s <UNIX socket path>
-p <pid file path>
-u <user>
-g <group>
-m <mail spool prefix>

USAGE

    exit(0);
}

if ($opt_d) {
    # This debug mode allows you to run your own checks against the maildir quota checker.
    $debugmode = 1;
    checkquota($opt_d);
    exit;
}
if ($opt_s) {
    $sockname = $opt_s;
}
if ($opt_p) {
    $pidfile = $opt_p;
}
if ($opt_u) {
    $server_user = $opt_u;
}
if ($opt_g) {
    $server_group = $opt_g;
}
if ($opt_m) {
    $mail_spool_prefix = $opt_m;
    die "mail spool prefix doesn't exist" unless (-d $mail_spool_prefix);
}

# check if we are already running
my $program_name = basename($0);
open(SELFLOCK, '<', "$0") or die("aborting: couldn't open $0: $!\n");
flock(SELFLOCK, LOCK_EX | LOCK_NB) or die("aborting: another $program_name is already running\n");

chdir('/') or die "aborting: can't chdir to '/': $!";

# drop privileges
setgid((getgrnam($server_user))[3])  or die "aborting: setgid() failed: $?";
setuid((getpwnam($server_group))[2]) or die "aborting: setuid() failed: $?";

# daemonize so that we run in the background.
defined (my $pid = fork) or die "can't fork: $!";
exit if ($pid);

foreach my $sig ($SIG{TSTP}, $SIG{TTIN}, $SIG{TTOU}, $SIG{HUP}) {
    $sig = 'IGNORE';
}

# record our pid.
open(PIDFILE, '>', "$pidfile") or die "can't create pidfile $pidfile: $!|";
print PIDFILE getpid();
close(PIDFILE) or warn "close pidfile $pidfile failed: $!";

open STDIN, '/dev/null' or die "can't read /dev/null: $!";
open STDOUT, '>>/dev/null' or die "can't write to /dev/null: $!";
open STDERR, '>>/dev/null' or die "can't write to /dev/null: $!";
setsid or die "can't start a new session: $!";

# ignore broken pipes
$SIG{PIPE} = 'IGNORE';

# do the main bit.
mainloop();

sub mainloop {
    my ($client, $child, $maildirpath);

    # change our name
    $0 = "mailquotad";
    
    # make the socket and listen to it.
    unlink($sockname);
    my $socket = new IO::Socket::UNIX(Local => $sockname,
				  Type => SOCK_STREAM,
				  Listen => SOMAXCONN,
				  Reuse => 1) or die "socket failed: $!";
    chmod(0666, $sockname);
	
    $SIG{CHLD} = \&child_reap;

    while (1) {
	while ($client = $socket->accept()) {
	    if ($child = fork()) {
		    $client->close;
	    } elsif (defined($child)) {
		    $socket->close();
		    $client->autoflush(1);
		    # read the socket, expecting a path.
		    if (defined($maildirpath = <$client>)) {
			chomp($maildirpath);
			my $quotastatus = checkquota($maildirpath);
			print $client $quotastatus;
		    }
		    $client->close();
		    exit(0);
	    } else {
		    warn "$0 [$$] fork failed: $!";
	    }
	}
    }
}

sub checkquota {
    my $maildir = shift @_;
    my $size = 0;
    return -1 unless -d "${mail_spool_prefix}/${maildir}";
    find( sub { $size += -s if -f;}, "${mail_spool_prefix}/${maildir}");
    print "quota for $maildir is $size\n" if ($debugmode);
    return $size;
}

sub child_reap {
    1 until (-1 == waitpid(-1, WNOHANG));
    $SIG{CHLD} = \&child_reap;
}
